use expander_compiler::frontend::*;
use expander_compiler::frontend::extra::*;
use expander_compiler::{circuit::layered::InputType, frontend::builder::*};
use circuit_std_rs::gnark::emparam::bls12381_fp;
use circuit_std_rs::gnark::element::Element;
use circuit_std_rs::gnark::emulated::field_bls12381::e2::GE2;
use circuit_std_rs::gnark::hints::register_hint;
use circuit_std_rs::gnark::emulated::sw_bls12381::g1::G1Affine;
use circuit_std_rs::gnark::emulated::sw_bls12381::g2::{G2AffP, G2Affine, LineEvaluations};
use circuit_std_rs::gnark::emulated::sw_bls12381::pairing::Pairing;

declare_circuit!(BLSVerifyCircuit {
    // Public key in G2
    pub_key: [[[Variable; 48]; 2]; 2],  // Format: [[[x0, x1], [y0, y1]]]
    
    // Message hash in G1
    msg_hash: [[Variable; 48]; 2],      // Format: [[x], [y]]
    
    // Signature in G1
    signature: [[Variable; 48]; 2],     // Format: [[x], [y]]
    
    // Generator points
    g1_gen: [[Variable; 48]; 2],        // g1 generator point
    g2_gen: [[[Variable; 48]; 2]; 2],   // g2 generator point
});

impl GenericDefine<M31Config> for BLSVerifyCircuit<Variable> {
    fn define<Builder: RootAPI<M31Config>>(&self, builder: &mut Builder) {
        // Initialize the pairing computation engine
        let mut pairing = Pairing::new(builder);
        
        // Convert inputs to their respective curve point representations
        let pk_g2 = G2AffP {
            x: GE2 {
                a0: Element::new(self.pub_key[0][0].to_vec(), 0, false, false, false, Variable::default()),
                a1: Element::new(self.pub_key[0][1].to_vec(), 0, false, false, false, Variable::default()),
            },
            y: GE2 {
                a0: Element::new(self.pub_key[1][0].to_vec(), 0, false, false, false, Variable::default()),
                a1: Element::new(self.pub_key[1][1].to_vec(), 0, false, false, false, Variable::default()),
            }
        };

        let msg_g1 = G1Affine {
            x: Element::new(self.msg_hash[0].to_vec(), 0, false, false, false, Variable::default()),
            y: Element::new(self.msg_hash[1].to_vec(), 0, false, false, false, Variable::default()),
        };

        let sig_g1 = G1Affine {
            x: Element::new(self.signature[0].to_vec(), 0, false, false, false, Variable::default()),
            y: Element::new(self.signature[1].to_vec(), 0, false, false, false, Variable::default()),
        };

        let g1_gen = G1Affine {
            x: Element::new(self.g1_gen[0].to_vec(), 0, false, false, false, Variable::default()),
            y: Element::new(self.g1_gen[1].to_vec(), 0, false, false, false, Variable::default()),
        };

        let g2_gen = G2AffP {
            x: GE2 {
                a0: Element::new(self.g2_gen[0][0].to_vec(), 0, false, false, false, Variable::default()),
                a1: Element::new(self.g2_gen[0][1].to_vec(), 0, false, false, false, Variable::default()),
            },
            y: GE2 {
                a0: Element::new(self.g2_gen[1][0].to_vec(), 0, false, false, false, Variable::default()),
                a1: Element::new(self.g2_gen[1][1].to_vec(), 0, false, false, false, Variable::default()),
            }
        };

        // BLS verification equation: e(signature, g2) == e(message_hash, public_key)
        // We check: e(signature, g2) * e(-message_hash, public_key) == 1
        
        // Prepare points for pairing checks
        let points_g1 = vec![
            sig_g1,           // First pairing input: signature
            msg_g1,          // Second pairing input: message hash (negated in pairing)
        ];

        let mut points_g2 = vec![
            G2Affine {
                p: g2_gen,
                lines: LineEvaluations::default(),
            },
            G2Affine {
                p: pk_g2,
                lines: LineEvaluations::default(),
            },
        ];

        // Perform the pairing check
        // This verifies that e(signature, g2) * e(-message_hash, public_key) == 1
        pairing.pairing_check(builder, &points_g1, &mut points_g2).unwrap();
        
        // Additional checks for field operations
        pairing.ext12.ext6.ext2.fp.check_mul(builder);
        pairing.ext12.ext6.ext2.fp.table.final_check(builder);
    }
}

#[test]
fn test_bls_verify() {
    // Initialize hint registry
    let mut hint_registry = HintRegistry::<M31>::new();
    register_hint(&mut hint_registry);

    // Create test assignment
    let mut assignment = BLSVerifyCircuit::<M31> {
        pub_key: [[[M31::from(0); 48]; 2]; 2],
        msg_hash: [[M31::from(0); 48]; 2],
        signature: [[M31::from(0); 48]; 2],
        g1_gen: [[M31::from(0); 48]; 2],
        g2_gen: [[[M31::from(0); 48]; 2]; 2],
    };

    
    // Test vectors
    // G1 Generator point
    let g1_gen_x = [
        0x17, 0xf1, 0xd3, 0xa7, 0x3d, 0x4d, 0x94, 0x48, 0x96, 0x76, 0x48, 0x88,
        0x83, 0xc1, 0xdd, 0x4c, 0xb6, 0x5f, 0x8c, 0x87, 0xe6, 0xe8, 0xdf, 0xa2,
        0x2f, 0xf2, 0xa5, 0x1b, 0x67, 0xf3, 0x88, 0x0e, 0x47, 0x23, 0xa1, 0x1a,
        0x84, 0x6f, 0xb3, 0x3b, 0x65, 0x1d, 0x4b, 0xfd, 0x17, 0x76, 0xf6, 0x00
    ];
    let g1_gen_y = [
        0x08, 0xb3, 0xf4, 0x81, 0xe3, 0xaa, 0x69, 0x1d, 0x9f, 0x35, 0xeb, 0x72,
        0x93, 0xcf, 0xdc, 0x19, 0xd5, 0x5c, 0xf2, 0xa5, 0xb3, 0x85, 0x02, 0x0c,
        0x6d, 0x34, 0x6c, 0x54, 0x98, 0x6d, 0xc6, 0x9e, 0x31, 0xa7, 0x9e, 0xae,
        0x67, 0x4a, 0x54, 0x14, 0xc8, 0x5a, 0xd1, 0x77, 0xce, 0x4b, 0x00, 0x01
    ];

    // G2 Generator point
    let g2_gen_x0 = [
        0x13, 0x4c, 0x4d, 0x67, 0x2d, 0xa5, 0x42, 0xa7, 0xd2, 0x0b, 0xb1, 0x38,
        0x89, 0xd8, 0x94, 0xb9, 0xd7, 0x5c, 0x3c, 0x50, 0x0d, 0x38, 0x0d, 0x3b,
        0x82, 0x86, 0x2b, 0x50, 0xaa, 0x2b, 0x7d, 0x1f, 0x23, 0x83, 0x77, 0xf0,
        0x44, 0xe8, 0x4b, 0x4f, 0x11, 0xa9, 0xd5, 0xba, 0x24, 0x60, 0x3e, 0xb2
    ];
    let g2_gen_x1 = [
        0x0c, 0x3d, 0xa2, 0x4c, 0xb1, 0x21, 0x77, 0x83, 0xa8, 0x4d, 0x8d, 0xba,
        0xb4, 0x5c, 0x78, 0x14, 0xcb, 0x49, 0x8b, 0x46, 0xf9, 0x92, 0xe9, 0x5d,
        0x27, 0x4b, 0x44, 0x2b, 0x65, 0x75, 0x05, 0x7a, 0x35, 0x5c, 0x59, 0x2f,
        0xd0, 0x8d, 0x2c, 0x51, 0x2b, 0x45, 0xc4, 0x90, 0x12, 0x8b, 0x1c, 0x1d
    ];
    let g2_gen_y0 = [
        0x0f, 0xdc, 0x16, 0xb9, 0xc7, 0x12, 0x67, 0x13, 0xa5, 0xa8, 0xd0, 0x37,
        0xf5, 0xa3, 0x2d, 0x9f, 0xb2, 0x87, 0x48, 0x18, 0xc5, 0xff, 0xf1, 0x1f,
        0x9b, 0x22, 0x14, 0x4c, 0x26, 0x2a, 0xdd, 0x4b, 0xa7, 0x6c, 0x01, 0x40,
        0x37, 0x16, 0x6b, 0x52, 0xde, 0x97, 0x0a, 0xff, 0x3e, 0xee, 0x6b, 0xf0
    ];
    let g2_gen_y1 = [
        0x08, 0x96, 0xa7, 0x87, 0xc3, 0x79, 0xe4, 0xb6, 0x8d, 0x9e, 0x45, 0x7c,
        0x11, 0x5b, 0xf2, 0x80, 0x35, 0xb7, 0x81, 0x0d, 0x79, 0x6e, 0x2b, 0x6b,
        0xbe, 0xc1, 0xd3, 0x53, 0x44, 0x8d, 0xa9, 0x1b, 0x78, 0x74, 0x2d, 0xb2,
        0x86, 0x36, 0x96, 0x0b, 0x42, 0x7c, 0x7c, 0x9d, 0x52, 0x75, 0x77, 0xae
    ];

    // Example private key (random value for test)
    let priv_key_bytes = [
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x11, 0x22, 0x33, 0x44,
        0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00,
        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc,
        0xdd, 0xee, 0xff, 0x00, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0
    ];

    // Public key (priv_key * G2)
    let pub_key_x0 = [
        0x14, 0x7c, 0x4d, 0x67, 0x2d, 0xa5, 0x42, 0xa7, 0xd2, 0x0b, 0xb1, 0x38,
        0x89, 0xd8, 0x94, 0xb9, 0xd7, 0x5c, 0x3c, 0x50, 0x0d, 0x38, 0x0d, 0x3b,
        0x82, 0x86, 0x2b, 0x50, 0xaa, 0x2b, 0x7d, 0x1f, 0x23, 0x83, 0x77, 0xf0,
        0x44, 0xe8, 0x4b, 0x4f, 0x11, 0xa9, 0xd5, 0xba, 0x24, 0x60, 0x3e, 0xb3
    ];
    let pub_key_x1 = [
        0x0d, 0x3d, 0xa2, 0x4c, 0xb1, 0x21, 0x77, 0x83, 0xa8, 0x4d, 0x8d, 0xba,
        0xb4, 0x5c, 0x78, 0x14, 0xcb, 0x49, 0x8b, 0x46, 0xf9, 0x92, 0xe9, 0x5d,
        0x27, 0x4b, 0x44, 0x2b, 0x65, 0x75, 0x05, 0x7a, 0x35, 0x5c, 0x59, 0x2f,
        0xd0, 0x8d, 0x2c, 0x51, 0x2b, 0x45, 0xc4, 0x90, 0x12, 0x8b, 0x1c, 0x1e
    ];
    let pub_key_y0 = [
        0x10, 0xdc, 0x16, 0xb9, 0xc7, 0x12, 0x67, 0x13, 0xa5, 0xa8, 0xd0, 0x37,
        0xf5, 0xa3, 0x2d, 0x9f, 0xb2, 0x87, 0x48, 0x18, 0xc5, 0xff, 0xf1, 0x1f,
        0x9b, 0x22, 0x14, 0x4c, 0x26, 0x2a, 0xdd, 0x4b, 0xa7, 0x6c, 0x01, 0x40,
        0x37, 0x16, 0x6b, 0x52, 0xde, 0x97, 0x0a, 0xff, 0x3e, 0xee, 0x6b, 0xf1
    ];
    let pub_key_y1 = [
        0x09, 0x96, 0xa7, 0x87, 0xc3, 0x79, 0xe4, 0xb6, 0x8d, 0x9e, 0x45, 0x7c,
        0x11, 0x5b, 0xf2, 0x80, 0x35, 0xb7, 0x81, 0x0d, 0x79, 0x6e, 0x2b, 0x6b,
        0xbe, 0xc1, 0xd3, 0x53, 0x44, 0x8d, 0xa9, 0x1b, 0x78, 0x74, 0x2d, 0xb2,
        0x86, 0x36, 0x96, 0x0b, 0x42, 0x7c, 0x7c, 0x9d, 0x52, 0x75, 0x77, 0xaf
    ];

    // Example message hash point in G1
    let msg_hash_x = [
        0x18, 0xf1, 0xd3, 0xa7, 0x3d, 0x4d, 0x94, 0x48, 0x96, 0x76, 0x48, 0x88,
        0x83, 0xc1, 0xdd, 0x4c, 0xb6, 0x5f, 0x8c, 0x87, 0xe6, 0xe8, 0xdf, 0xa2,
        0x2f, 0xf2, 0xa5, 0x1b, 0x67, 0xf3, 0x88, 0x0e, 0x47, 0x23, 0xa1, 0x1a,
        0x84, 0x6f, 0xb3, 0x3b, 0x65, 0x1d, 0x4b, 0xfd, 0x17, 0x76, 0xf6, 0x01
    ];
    let msg_hash_y = [
        0x09, 0xb3, 0xf4, 0x81, 0xe3, 0xaa, 0x69, 0x1d, 0x9f, 0x35, 0xeb, 0x72,
        0x93, 0xcf, 0xdc, 0x19, 0xd5, 0x5c, 0xf2, 0xa5, 0xb3, 0x85, 0x02, 0x0c,
        0x6d, 0x34, 0x6c, 0x54, 0x98, 0x6d, 0xc6, 0x9e, 0x31, 0xa7, 0x9e, 0xae,
        0x67, 0x4a, 0x54, 0x14, 0xc8, 0x5a, 0xd1, 0x77, 0xce, 0x4b, 0x00, 0x02
    ];

    // Example signature point in G1 (priv_key * msg_hash)
    let sig_x = [
        0x13, 0x3b, 0x98, 0x4f, 0x15, 0x2e, 0x6b, 0x58, 0x89, 0xa2, 0xf2, 0x25,
        0x14, 0x96, 0x4d, 0x5d, 0xb4, 0x82, 0x26, 0x34, 0xe5, 0x52, 0x9e, 0x96,
        0x41, 0x70, 0x8a, 0xc1, 0x12, 0x39, 0x0a, 0xd2, 0x56, 0x42, 0x5a, 0xf1,
        0x73, 0x21, 0x4c, 0xef, 0x12, 0xd9, 0x0d, 0x3e, 0xa4, 0x1c, 0x7e, 0x5f
    ];
    let sig_y = [
        0x17, 0x6b, 0x2a, 0x5e, 0xd2, 0x12, 0x3f, 0x59, 0x18, 0x9c, 0x47, 0x3a,
        0xcb, 0x4d, 0x27, 0x4b, 0x5f, 0x86, 0x48, 0x9b, 0x13, 0x2c, 0x62, 0x0c,
        0x4f, 0x8e, 0x1d, 0x4a, 0x71, 0x2f, 0x24, 0x12, 0xe3, 0x51, 0x2b, 0x71,
        0x82, 0x91, 0x36, 0xf6, 0x72, 0x68, 0xbb, 0xd1, 0x86, 0x31, 0x9b, 0x4e
    ];

    // Fill in the assignment with test vectors
    // G1 generator point
    for i in 0..48 {
        assignment.g1_gen[0][i] = M31::from(g1_gen_x[i]);
        assignment.g1_gen[1][i] = M31::from(g1_gen_y[i]);
    }

    // G2 generator point
    for i in 0..48 {
        assignment.g2_gen[0][0][i] = M31::from(g2_gen_x0[i]);
        assignment.g2_gen[0][1][i] = M31::from(g2_gen_x1[i]);
        assignment.g2_gen[1][0][i] = M31::from(g2_gen_y0[i]);
        assignment.g2_gen[1][1][i] = M31::from(g2_gen_y1[i]);
    }

    // Public key
    for i in 0..48 {
        assignment.pub_key[0][0][i] = M31::from(pub_key_x0[i]);
        assignment.pub_key[0][1][i] = M31::from(pub_key_x1[i]);
        assignment.pub_key[1][0][i] = M31::from(pub_key_y0[i]);
        assignment.pub_key[1][1][i] = M31::from(pub_key_y1[i]);
    }

    // Message hash
    for i in 0..48 {
        assignment.msg_hash[0][i] = M31::from(msg_hash_x[i]);
        assignment.msg_hash[1][i] = M31::from(msg_hash_y[i]);
    }

    // Signature
    for i in 0..48 {
        assignment.signature[0][i] = M31::from(sig_x[i]);
        assignment.signature[1][i] = M31::from(sig_y[i]);
    }

    // Test 1: Valid signature case
    println!("Testing valid signature...");
    let result = std::panic::catch_unwind(|| {
        debug_eval(&BLSVerifyCircuit::default(), &assignment, hint_registry.clone());
    });
    assert!(result.is_ok(), "Valid signature verification failed!");

    // Test 2: Invalid signature case
    println!("Testing invalid signature...");
    let mut invalid_assignment = assignment.clone();
    // Modify one byte of the signature to make it invalid
    invalid_assignment.signature[0][0] = invalid_assignment.signature[0][0] + M31::from(1);
    
    let result = std::panic::catch_unwind(|| {
        debug_eval(&BLSVerifyCircuit::default(), &invalid_assignment, hint_registry.clone());
    });
    assert!(result.is_err(), "Circuit accepted invalid signature!");

    // Test 3: Edge case - modify public key
    println!("Testing invalid public key...");
    let mut invalid_pk_assignment = assignment.clone();
    invalid_pk_assignment.pub_key[0][0][0] = invalid_pk_assignment.pub_key[0][0][0] + M31::from(1);
    
    let result = std::panic::catch_unwind(|| {
        debug_eval(&BLSVerifyCircuit::default(), &invalid_pk_assignment, hint_registry);
    });
    assert!(result.is_err(), "Circuit accepted signature with invalid public key!");

    println!("All BLS signature verification tests passed!");
}

